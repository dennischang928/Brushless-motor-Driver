/*
  All-in-one setPWM
  This example shows how to configure a PWM with HardwareTimer in one single function call.
  PWM is generated on `LED_BUILTIN` if available.
  No interruption callback used: PWM is generated by hardware.
  Once configured, there is no CPU load.
*/

/*
  Note: Please verify that 'pin' used for PWM has HardwareTimer capability for your board
  This is specially true for F1 serie (BluePill, ...)
*/
//HardwareSerial Serial1(PB7, PB6);


TIM_HandleTypeDef htim2;


#define pin1  PA8
#define pin2  PA9
#define pin3  PA10

static inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)
{
  if (from != to) {
    if (from > to) {
      value = (value < (uint32_t)(1 << (from - to))) ? 0 : ((value + 1) >> (from - to)) - 1;
    } else {
      if (value != 0) {
        value = ((value + 1) << (to - from)) - 1;
      }
    }
  }
  return value;
}


void Compare_IT_callback() {
  digitalWrite(PA11, LOW);
}

TIM_TypeDef *Instance1 = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(pin1), PinMap_PWM);
TIM_TypeDef *Instance2 = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(pin2), PinMap_PWM);
TIM_TypeDef *Instance3 = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(pin3), PinMap_PWM);


uint32_t channel1 = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(pin1), PinMap_PWM));
uint32_t channel2 = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(pin2), PinMap_PWM));
uint32_t channel3 = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(pin3), PinMap_PWM));

// Instantiate HardwareTimer object. Thanks to 'new' instantiation, HardwareTimer is not destructed when setup function is finished.
HardwareTimer *MyTim1 = new HardwareTimer(Instance1);
int Cycle = 0;
void OverFlow () {

  if (Cycle == 10) {
    Cycle = 0;
    digitalWrite(PA11, HIGH);
  }
  //  Serial2.println(i);

  Cycle ++;
}

void setup()
{
  
  //  Serial1.begin(115200);
  pinMode(PB1, INPUT);

  pinMode(PC13, OUTPUT);
  pinMode(PA11, OUTPUT);
  // No need to configure pin, it will be done by HardwareTimer configuration
  // pinMode(pin, OUTPUT);

  // Need to configure pin2, as it is not managed by HardwareTimer

  // Automatically retrieve TIM instance and channel associated to pin
  // This is used to be compatible with all STM32 series automatically.


  MyTim1->setMode(channel1, TIMER_OUTPUT_COMPARE_PWM2, pin1);
  MyTim1->setMode(channel2, TIMER_OUTPUT_COMPARE_PWM2, pin2);
  MyTim1->setMode(channel3, TIMER_OUTPUT_COMPARE_PWM2, pin3);

  //   MyTim->setPrescaleFactor(8); // Due to setOverflow with MICROSEC_FORMAT, prescaler will be computed automatically based on timer input clock
  MyTim1->setOverflow(20000, HERTZ_FORMAT); // 10 Hz

  MyTim1->attachInterrupt(OverFlow);
  MyTim1->attachInterrupt(channel1, Compare_IT_callback);

  MyTim1->setCaptureCompare(channel1, 4095 - 1000, RESOLUTION_12B_COMPARE_FORMAT); // 50%
  MyTim1->setCaptureCompare(channel2, 4095 - 1000, RESOLUTION_12B_COMPARE_FORMAT); // 50%
  MyTim1->setCaptureCompare(channel3, 4095 - 1000, RESOLUTION_12B_COMPARE_FORMAT); // 50%

  MyTim1->resume();
}


void loop() {

}
